
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>React и его архитектурная противоречивость. А также шокирующие откровения архитекторов без купюр</title>
	<style type="text/css">
		body { font-family: Georgia, 'Times New Roman', Times, serif; }

		p {margin-top: 0}
		.wrap {
			padding-top: 2rem;
			max-width: 70rem;
			margin: 0 auto;
		}

		.wrap > * {
			max-width: 50rem;
		}

		.brace {
			float:right;
			margin-left: 4rem;
			font-style: italic;
			max-width: 25rem;
		}
		.brace:after {
			content: ' ';
			height: 1px;
			display:block;
			clear: right;
		}
	</style>
</head>
<body>
<div class="wrap">
		<div class="brace">
			React - инструмент, созданный для упрощения процесса разработки и быстрого рендеринга
		</div>
		<p>
			React препятствует задачам упрощения разработки уже сейчас и задачам по улучшению производительности в ближайшей перспективе.
		</p>
		<p>
			Первое (по сути не имеет отношение, но позволяет понять последовательность и глубину комплексного подхода к решению проблем): архитектор заявляет что любит javascript и всякие выдуманные синтаксисы использовать не любит. Предлагает использовать JSX. OK
		</p>
		<p>
			Второе: что важно отметить это то, что разработчики вводят в заблуждение, <a href="https://facebook.github.io/react/docs/why-react.html">заявляя что реакт - декларативный</a>.
			<br/>

			По настоящему декларативный инструмент позволяет анализировать ожидаемый результат и делать оптимизации для его получения. Такими инструментами можно назвать SQL (во множестве случаев) или запросы в datomic. В реакте же невозможно программно проанализировать от каких состояний зависит та или иная часть DOM дерева, какое состояние может его кардинально поменять и т.д. В реакте декларативен только результат выполнения функции render(), но это не очень интересно потому что он меняется в зависимости от состояний.
		</p>
		<p>
			В связи с этим react не знает как конкретно DOM связан с данными поэтому они выполняют дорогие сравнения virtual dom (Ради решения этой проблемы они предлагают использовать immutable)
		</p>
		<p>
		Третье: отдельно <a href="https://www.youtube.com/watch?v=-DX3vJiqxm4&feature=youtu.be&t=13m2s">отмечены архитектором react</a>
		</p>
		<ul>
			<li>отказ от использования причинно следственных связей, зависимостей в данных и, собственно, автоматического атомарного изменения данных при изменении зависимостей, а также автоматической перерисовки частей как реакции на изменения (При этом за счёт атомарных же изменений в DOM сам react решает проблему производительности). Вместо этого предлагается ручное обновление данных, ручной вызов рендеринга</li>
			<li>
				предложение перегенирировать вновь и вновь структуры данных
			</li>
		</ul>
		<p>После этого вдруг, откуда ни возьмись, неожиданно и несправедливо, без объявления войны, с вертушки выясняется  что счётчик непрочитанных сообщений показывает неверное число.</p>
		<p>Решение проблемы радикально: выкинуть MVC подход и использовать flux, который позволяет немного систематизировать ручное обновление данных.</p>

		<p>Уже сейчас, в результате отказа от настоящей декларативности, умышленного отказа от наблюдения/реакции на изменения данных для реакта стоновится проблемой производительность и помощь в организации кода.</p>
		<p>
			Уже сейчас и в ближайщем будущем фиктивная декларативность препятствует другой задачи, которую ставят перед собой архитекторы react:
эффективное взаимодействие с сервером. Есть <a href="https://facebook.github.io/graphql/">graphql</a>, но запросы разработчик должен писать сам, хотя они могли бы генерироваться автоматически - используемую структуру данных нетрудно вычислить из шаблонов.
		</p>

		<h3>Как должно быть</h3>
		<h4>Производительность</h4>
		<p>По настоящему декларативные шаблоны (а не так как в реакте - тысячи генерируемых на лету деклараций DOM дерева).</p>
		<p>Из которых понятны взаимосвязь с данными. А значит можно выполнять атомарные изменения-реакции в DOM на изменения данных без промежуточных шагов. На основе которых можно построить все варианты состояний DOM, благодаря чему анализировать css и делать приоритезацию тяжелых, влияющих на reflow/repaint изменений.</p>
		<p>Когда браузер понимает как будет меняться DOM он может сделать много крутых оптимизаций.</p>

		<h4>Эффективность кода</h4>
		<p>
			Взаимосвязи между данными описываются декларативно. Структуры взаимосвязей данных, а также используемые в шаблонах структуры склеиваются.
			<br>Для основных объектов приложения у сервера спрашивается:
		</p>
		<p>"У нас тут в приложении есть статьи такой-то структуры. Как бы эффективно у тебя, сервер, забирать статьи и всё что с ними связано?"</p>

<pre>
{

  props: ['full_text', 'date'],

  related: {

    author: {

      props: ['firstName', 'lastName'],

      related: {

        avatarUrl: ['url', 'width', 'height']
      }
    }
  }
}
</pre>
		<p>А сервер такой говорит: "ну ты можешь запрашивать посты и получать такую структуру по этому url /api/135H49VXUHN/"</p>
		<p>Приложение когда надо запрашивает /api/135H49VXUHN/24234234?author.avatarUrl.width=320&author.avatarUrl.width=240. Сервер отвечает</p>
		<p>Сервер складывает вместе одинаковые стукруры об эффективности которых просят разные клиентские приложения. Складывает и мониторит - какие структуры создают большую нагрузку на сервер и показывает их программисту. А программист либо отключает структуруры (клиент получает редирект на структуры попроще) либо начинает жестко оптимизировать их, добавлять индексы, улучшать алгоритмы.</p>

		<p>Это кардиранольное улучшение разработки может быть выполнено в атоматическом режиме, для этого шаблоны должны быть декларативными как и взаимосвязи между состояниями моделей и сервером.</p>


</div>

</body>
</html>
